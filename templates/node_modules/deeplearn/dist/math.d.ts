import { BackendType, ENV } from './environment';
import { KernelBackend } from './kernels/backend';
import * as array_ops from './ops/array_ops';
import * as batchnorm from './ops/batchnorm';
import * as binary_ops from './ops/binary_ops';
import * as compare from './ops/compare';
import * as conv from './ops/conv';
import * as image_ops from './ops/image_ops';
import * as logical from './ops/logical_ops';
import * as lrn_ops from './ops/lrn';
import * as lstm_ops from './ops/lstm';
import * as matmul from './ops/matmul';
import * as norm from './ops/norm';
import * as pool from './ops/pool';
import * as reduction_ops from './ops/reduction_ops';
import * as reverse from './ops/reverse';
import * as slice from './ops/slice';
import * as softmax_ops from './ops/softmax';
import * as transpose from './ops/transpose';
import * as unary_ops from './ops/unary_ops';
import { ScopeResult } from './tape_util';
import { Scalar, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D } from './tensor';
import { Tracking } from './tracking';
import { Rank } from './types';
export declare class NDArrayMath {
    matMul: typeof matmul.Ops.matMul;
    vectorTimesMatrix: typeof matmul.Ops.vectorTimesMatrix;
    outerProduct: typeof matmul.Ops.outerProduct;
    matrixTimesVector: typeof matmul.Ops.matrixTimesVector;
    dotProduct: typeof matmul.Ops.dotProduct;
    slice: typeof slice.Ops.slice;
    slice1D: typeof slice.Ops.slice1d;
    slice2D: typeof slice.Ops.slice2d;
    slice3D: typeof slice.Ops.slice3d;
    slice4D: typeof slice.Ops.slice4d;
    reverse: typeof reverse.Ops.reverse;
    reverse1D: typeof reverse.Ops.reverse1d;
    reverse2D: typeof reverse.Ops.reverse2d;
    reverse3D: typeof reverse.Ops.reverse3d;
    reverse4D: typeof reverse.Ops.reverse4d;
    batchNormalization: typeof batchnorm.Ops.batchNormalization;
    batchNormalization2D: typeof batchnorm.Ops.batchNormalization2d;
    batchNormalization3D: typeof batchnorm.Ops.batchNormalization3d;
    batchNormalization4D: typeof batchnorm.Ops.batchNormalization4d;
    avgPool: typeof pool.Ops.avgPool;
    maxPool: typeof pool.Ops.maxPool;
    minPool: typeof pool.Ops.minPool;
    maxPoolBackprop: typeof pool.Ops.maxPoolBackprop;
    conv2dTranspose: typeof conv.Ops.conv2dTranspose;
    depthwiseConv2D: typeof conv.Ops.depthwiseConv2d;
    conv2dDerFilter: typeof conv.Ops.conv2dDerFilter;
    conv2dDerInput: typeof conv.Ops.conv2dDerInput;
    argMax: typeof reduction_ops.Ops.argMax;
    argMin: typeof reduction_ops.Ops.argMin;
    logSumExp: typeof reduction_ops.Ops.logSumExp;
    max: typeof reduction_ops.Ops.max;
    mean: typeof reduction_ops.Ops.mean;
    min: typeof reduction_ops.Ops.min;
    moments: typeof reduction_ops.Ops.moments;
    sum: typeof reduction_ops.Ops.sum;
    add: typeof binary_ops.Ops.add;
    addStrict: typeof binary_ops.Ops.addStrict;
    div: typeof binary_ops.Ops.div;
    divide: typeof binary_ops.Ops.div;
    divStrict: typeof binary_ops.Ops.divStrict;
    divideStrict: typeof binary_ops.Ops.divStrict;
    maximum: typeof binary_ops.Ops.maximum;
    maximumStrict: typeof binary_ops.Ops.maximumStrict;
    minimum: typeof binary_ops.Ops.minimum;
    minimumStrict: typeof binary_ops.Ops.minimumStrict;
    mul: typeof binary_ops.Ops.mul;
    multiply: typeof binary_ops.Ops.mul;
    mulStrict: typeof binary_ops.Ops.mulStrict;
    multiplyStrict: typeof binary_ops.Ops.mulStrict;
    pow: typeof binary_ops.Ops.pow;
    powStrict: typeof binary_ops.Ops.powStrict;
    sub: typeof binary_ops.Ops.sub;
    subtract: typeof binary_ops.Ops.sub;
    subStrict: typeof binary_ops.Ops.subStrict;
    logicalNot: typeof logical.Ops.logicalNot;
    logicalAnd: typeof logical.Ops.logicalAnd;
    logicalOr: typeof logical.Ops.logicalOr;
    logicalXor: typeof logical.Ops.logicalXor;
    where: typeof logical.Ops.where;
    transpose: typeof transpose.Ops.transpose;
    equal: typeof compare.Ops.equal;
    equalStrict: typeof compare.Ops.equalStrict;
    greater: typeof compare.Ops.greater;
    greaterStrict: typeof compare.Ops.greaterStrict;
    greaterEqual: typeof compare.Ops.greaterEqual;
    greaterEqualStrict: typeof compare.Ops.greaterEqualStrict;
    less: typeof compare.Ops.less;
    lessStrict: typeof compare.Ops.lessStrict;
    lessEqual: typeof compare.Ops.lessEqual;
    lessEqualStrict: typeof compare.Ops.lessEqualStrict;
    notEqual: typeof compare.Ops.notEqual;
    notEqualStrict: typeof compare.Ops.notEqualStrict;
    abs: typeof unary_ops.Ops.abs;
    acos: typeof unary_ops.Ops.acos;
    asin: typeof unary_ops.Ops.asin;
    atan: typeof unary_ops.Ops.atan;
    ceil: typeof unary_ops.Ops.ceil;
    clip: typeof unary_ops.Ops.clipByValue;
    cos: typeof unary_ops.Ops.cos;
    cosh: typeof unary_ops.Ops.cosh;
    elu: typeof unary_ops.Ops.elu;
    exp: typeof unary_ops.Ops.exp;
    floor: typeof unary_ops.Ops.floor;
    leakyRelu: typeof unary_ops.Ops.leakyRelu;
    log: typeof unary_ops.Ops.log;
    neg: typeof unary_ops.Ops.neg;
    prelu: typeof unary_ops.Ops.prelu;
    relu: typeof unary_ops.Ops.relu;
    selu: typeof unary_ops.Ops.selu;
    sigmoid: typeof unary_ops.Ops.sigmoid;
    sin: typeof unary_ops.Ops.sin;
    sinh: typeof unary_ops.Ops.sinh;
    sqrt: typeof unary_ops.Ops.sqrt;
    square: typeof unary_ops.Ops.square;
    step: typeof unary_ops.Ops.step;
    tan: typeof unary_ops.Ops.tan;
    tanh: typeof unary_ops.Ops.tanh;
    norm: typeof norm.Ops.norm;
    basicLSTMCell: typeof lstm_ops.Ops.basicLSTMCell;
    multiRNNCell: typeof lstm_ops.Ops.multiRNNCell;
    softmax: typeof softmax_ops.Ops.softmax;
    softmaxCrossEntropy: typeof softmax_ops.Ops.softmaxCrossEntropy;
    cast: typeof array_ops.Ops.cast;
    clone: typeof array_ops.Ops.clone;
    gather: typeof array_ops.Ops.gather;
    reshape: typeof array_ops.Ops.reshape;
    tile: typeof array_ops.Ops.tile;
    oneHot: typeof array_ops.Ops.oneHot;
    multinomial: typeof array_ops.Ops.multinomial;
    pad1D: typeof array_ops.Ops.pad1d;
    pad2D: typeof array_ops.Ops.pad2d;
    resizeBilinear3D: typeof image_ops.Ops.resizeBilinear;
    localResponseNormalization3D: typeof lrn_ops.LRN.localResponseNormalization;
    localResponseNormalization4D: typeof lrn_ops.LRN.localResponseNormalization;
    keep: typeof Tracking.keep;
    engine: typeof ENV.engine;
    dispose: typeof ENV.engine.dispose;
    registeredVariables: typeof ENV.engine.registeredVariables;
    startScope: typeof ENV.engine.startScope;
    endScope: typeof ENV.engine.endScope;
    constructor(backend: BackendType | KernelBackend, safeMode: boolean);
    scope<T extends ScopeResult>(scopeFn?: ScopeFn<T>): T;
    track<T extends Tensor>(result: T): T;
    topK(x: Tensor, k: number): {
        values: Tensor1D;
        indices: Tensor1D;
    };
    elementWiseMul<T extends Tensor>(a: T, b: T): T;
    scalarDividedByArray<T extends Tensor>(c: Scalar, a: T): T;
    arrayDividedByScalar<T extends Tensor>(a: T, c: Scalar): T;
    switchDim<R extends Rank>(x: Tensor<R>, perm?: number[]): Tensor<R>;
    scalarPlusArray<T extends Tensor>(c: Scalar, a: T): T;
    scalarMinusArray<T extends Tensor>(c: Scalar, a: T): T;
    arrayMinusScalar<T extends Tensor>(a: T, c: Scalar): T;
    scaledArrayAdd<T extends Tensor>(c1: Scalar, a: T, c2: Scalar, b: T): T;
    scalarTimesArray<T extends Tensor>(c: Scalar, a: T): T;
    concat<T extends Tensor>(a: T, b: T, axis: number): T;
    concat1D(a: Tensor1D, b: Tensor1D): Tensor1D;
    concat2D(a: Tensor2D, b: Tensor2D, axis: number): Tensor2D;
    concat3D(a: Tensor3D, b: Tensor3D, axis: number): Tensor3D;
    concat4D(a: Tensor4D, b: Tensor4D, axis: number): Tensor4D;
    conv1d<T extends Tensor2D | Tensor3D>(input: T, filter: Tensor3D, bias: Tensor1D | null, stride: number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    conv2d<T extends Tensor3D | Tensor4D>(x: T, filter: Tensor4D, bias: Tensor1D | null, strides: [number, number] | number, pad: 'valid' | 'same' | number, dimRoundingMode?: 'floor' | 'round' | 'ceil'): T;
    argMaxEquals(x1: Tensor, x2: Tensor): Scalar;
}
export declare type ScopeFn<T extends ScopeResult> = (keep: <T1 extends Tensor>(tensor: T1) => T1, track: <T2 extends Tensor>(tensor: T2) => T2) => T;
